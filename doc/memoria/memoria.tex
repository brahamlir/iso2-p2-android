% -*- coding:utf-8 -*-
\documentclass[12 pt, a4paper, twoside]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[spanish, activeacute]{babel}
\usepackage[pdftex, bookmarks, hyperfootnotes=false, colorlinks=true,%
            urlcolor=blue, linkcolor=black,  citecolor=black,%
            pagecolor=black, anchorcolor=black, breaklinks=true]{hyperref}
\usepackage{times}
\usepackage{eurosym}
\usepackage{hyperref}

\usepackage[pdftex]{graphicx}
%\usepackage{rotating}
\graphicspath{{img/}}

\usepackage{epstopdf}
\epstopdfsetup{outdir=img/,
  suffix=-generated}

\usepackage[pdftex]{color}
\definecolor{gray97}{gray}{.97}
\definecolor{gray75}{gray}{.75}
\definecolor{gray45}{gray}{.45}

\usepackage{listingsutf8}
\lstset{
  inputencoding = utf8/latin1,
                  %
                  frame = Ltb,
                  framerule = 0 pt,
                  aboveskip = 0.5 cm,
                  framextopmargin = 3 pt,
                  framexbottommargin = 3 pt,
                  framexleftmargin = 0.4 cm,
                  framesep = 0 pt,
                  rulesep = .4 pt,
                  backgroundcolor = \color{gray97},
                  rulesepcolor = \color{black},
                  %
                  stringstyle = \ttfamily,
                  showstringspaces  =  false,
                  basicstyle = \small\ttfamily,
                  commentstyle = \color{gray45},
                  keywordstyle = \bfseries,
                  %
                  numbers = left,
                  numbersep = 15 pt,
                  numberstyle = \tiny,
                  numberfirstline  =  false,
                  breaklines = true
}

\hypersetup{colorlinks = true, urlcolor = blue,
            pdftitle = Game Design Document,
            pdfsubject = Práctica de Ingeniería del Software II,
            pdfauthor = Varios}

\hoffset -0.54 cm
\voffset -0.54 cm
\textheight = 22 cm
\textwidth = 17 cm
\topmargin = 0 cm
\oddsidemargin = 0 cm
\evensidemargin = 0 cm
%\parindent = 0 cm
\parskip = 6 pt

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf[EH,EF,OH,OF]{}
\fancyhf[OLH]{Práctica 2}
\fancyhf[ERH]{Ingeniería del Software 2011-12}
\fancyhf[ELH]{\thepage}
\fancyhf[ORH]{\thepage}

\pdfimageresolution = 300

% \title{Práctica 2: {\em Game Design Document}\\Ingeniería del Software 2011-12}
% \author{Manuel José Abaldea García-Pliego\\
% Luis Miguel Garcia-Muñoz Pérez\\
% Eduardo Monroy Martínez\\
% Felipe Terriza García-Muñoz}
% \date{}

\begin{document}

%\maketitle

\input{portada}
\newpage

\tableofcontents

\newpage

\section{Sobre Android y las tecnologías utilizadas}
\subsection{Android}
\subsubsection{Estructura de la aplicación}
Aplicación = Manifiesto + Recursos + código
% AUMENTAR AQUÍ CON LO QUE HAGA FELIPE


\newpage
\subsection{Andengine}
\subsubsection{Introducción}
Smartphones, videojuegos, Android; son palabras que están en pleno
auge. Los smartphones son cada vez más potentes, con pantallas cada
vez mayores y de mayor definición; de modo que podemos disfrutar en
ellos de contenidos audiovisuales más y más pujantes. Unido esto a
un sistema operativo multifunción y completamente escalable como es
Android, obtenemos un entorno atractivo, actual y prometedor. Si
dentro de este entorno nos centramos en los videojuegos, nos
encontramos con Andengine.

Andengine es un framework utilizado como motor de juegos para Android. En
realidad utiliza una implementación 2D de OpenGl. Su
finalidad, como la de todos los frameworks, es optimizar el
esfuerzo del desarrollador ofreciéndonos una buena base desde donde
comenzar a crear nuestra propia aplicación.

AndEndgine se distribuye bajo licencia LGPL. Al desarrollar bajo LGPL se tiene la opción de elegir si el
programa final se licenciará como GPL, LGPL u otras licencias no
libres.

Ventajas de LGPL:
\begin{itemize}
\item Si en el desarrollo de un producto se utiliza código fuente
  licenciado bajo GPL o LGPL, no es obligatorio licenciar dicho
  producto final bajo dichas licencias.
\item LGPL es menos restrictiva que la licencia GPL, ya que sólo se
  ocupa en impedir el realizar versiones comerciales del producto
  licenciado bajo LGPL.
\item LGPL permite realizar versiones comerciales de un
  producto final que contenga como herramienta adicional un programa
  LGPL. Por lo tanto, LGPL puede ser utilizada o enlazada con software
  propietario.
\item LGPL exige registrar todos los cambios realizados por terceros,
  a manera de no afectar la reputación del autor original del
  software.
\end{itemize}

Desventajas de LGPL:
\begin{itemize}
\item Otras actividades que no sean copia, distribución o modificación
  no están cubiertas en esta licencia y están fuera de su alcance.
\end{itemize}

\clearpage
Las facilidades que ofrece AndEngine a la hora de desarrollar un
videojuego son de lo más completas, cuenta con:

\begin{itemize}
\item Motor. Es la pieza encargada de hacer que el juego
  funcione. Dispone de un hilo que refresca la ventana cada x
  milisegundos de tiempo. En cada tick se encarga de sincronizar los
  refrescos en pantalla y actualizar la escena.

\item Scene. La clase Scene es el contenedor de los Sprites que se
  deben visualizar en pantalla. Las escenas pueden tener capas
  (Layers) y entidades (Entities). Podemos encontrarnos también con
  sprites estáticos en la pantalla que servirán para visualizar menús,
  puntuaciones, energía, etc escenas compuestas por capas y entidades.

\item Texturas. Son imágenes en la memoria. Estas
  imágenes serán utilizadas para visualizar sprites o fondos. Por
  ello, en el momento de desarrollar siempre hay que tener en mente
  que por una parte se gestiona la información lógica de los objetos y
  por otra parte el aspecto visual que tiene o la textura.

\item Sprites. Son los objetos que se visualizan en el
  juego y en la mayoría de los casos son interactivos o
  animados. Existen varios tipos de sprites: titles en el que el juego
  tiene forma matricial, animados en los que el sprite dispondrá de
  varias imágenes o fotogramas o de background que se utilizarán para
  pintar fondos.

\item Física, motor físico del juego.
\item Detección de colisiones.
\item Música y efectos de sonido.También es posible reproducir
  ficheros de tipo sonido. Los formatos que es capaz de soportar son:
  AAC, MP3, Ogg, MIDI y WAV. Sin embargo, mediante una expansión es
  posible reproducir formatos de tipo trackers: MOD, S3M, IT, etc.
  Igualmente, es posible controlar características y eventos de la
  reproducción como subir y bajar el volumen, repetir el sonido,
  conocer si se está reproduciendo, situarse en una posición concreta
  del audio y algunas funciones más.

\end{itemize}

\subsubsection{Conceptos básicos}
A continuación describimos unos conceptos básicos necesarios para la
mejor comprensión del funcionamiento y desarrollo con AndEngine.

\begin{itemize}
\item \textbf{BaseGameActivity:} El BaseGameActivity es la raiz del
  juego, que contiene el motor y crea la vista donde se va a dibujar
  todo. Hay siempre exactamente un solo Engine por cada
  BaseGameActivity.
\item \textbf{Engine:} El Engine es el motor interno del juego, se
  encarga de ir dibujando en pantalla y actualizando objetos en la
  escena, que contiene todo el contenido que tu juego
  lleva. Normalmente hay una escena por por Engine, a menos que vayas
  a usar un SplitScreenEngines.
\item \textbf{IResolutionPolicy:} Una implementacion de
  IResolutionPolicy interface es parte del EngineOptions. Te hace
  abstraerte de la resolución del terminal, tú trabajas para una
  resolución y el AndEngine se encarga del resto.
\item \textbf{Camera:} Un objeto Camera define el rectangulo visible
  actualmente de la escena actual, no tiene porqué ser la escena
  completa. Normalmente hay una cámara por escena. Hay subclases
  específicas que permiten hacer zoom y mover la cámara suavemente.
\item \textbf{Scene:} La clase Scene es el contenedor para todos los
  objetos que se van a dibujar en la escena. Una escena puede tener
  Layers, que son capas para ordenar objetos. Hay subclases de la
  Scene como CameraScene/HUD/MenuScene que tienen comportamientos
  específicos.
\item \textbf{Entity:} Una entidad es un objeto que puede ser
  dibujado, como Imagenes, rectángulos, Texto, Líneas. Una entidad
  tiene posición/rotación/zoom/color...
\item \textbf{Texture:} Una textura es una imagen que se guarda en
  memoria. En Android, las imágenes deben ser una potencia de 2.
\item \textbf{ITextureSource:} Una implementacion de
  ITextureSource-interface se encarga de cargar una imagen en una
  posición en la textura.
\item \textbf{TextureRegion:} Una TextureRegion define un rectangulo
  en una imagen. Las TextureRegion se usan por Sprites para usar una
  imagen grande en la que guardamos muchas imagenes pequeñas.
\item \textbf{PhysicsConnector:} Motor de físicas integrado en el Engine
\end{itemize}

\section{Entorno de desarrollo}
Para desarrollar nuestra aplicación se ha optado por utilizar
Eclipse. La integración de las herramientas tanto de Android como de
AndEngine es sencilla, completa y está bien documentada.

Partiendo de tener Eclipse bien instalado en el sistema, nos hará
falta el SDK de Android, disponible en la página de desarrolladores,
área de descargas, este es el \href{
  http://developer.android.com/sdk/index.html}{link}.

Ahora es necesario configurar el plugin ADT en Eclipse. Desde Help =>
Install new software añadimos el repositorio:
\begin{verbatim}
https://dl-ssl.google.com/android/eclipse/
\end{verbatim}

%\begin{figure}[h!]
\includegraphics[width = 8 cm]{img/1.jpg}
\includegraphics[width = 8 cm]{img/2.jpg}
%\end{figure}

Para configurar ADT desde Windows => Preferences seleccionamos Android
en el panel izquierdo. Aquí debemos indicar la localización del SDK
que nos hemos descargado antes.

%\begin{figure}[h!]
\includegraphics[width = 7 cm]{img/3.jpg}
\includegraphics[width = 10 cm]{img/4.jpg}
%\end{figure}

\clearpage
Abriendo el SDK Android Manager podremos instalar diferentes APIs
según la versión de Android sobre la que queramos trabajar.

%\begin{figure}[h!]
\begin{center}
  \includegraphics[width = 10 cm]{img/5.jpg}

  \includegraphics[width = 14 cm]{img/6.jpg}
\end{center}
%\end{figure}

\clearpage
Si vamos a realizar pruebas sobre una máquina virtual de Android
debemos crearla primero.

%\begin{figure}[h!]
\begin{center}

\includegraphics[width = 8 cm]{img/7.jpg}

\includegraphics[width = 12 cm]{img/8.jpg}

\includegraphics[width = 10 cm]{img/9.jpg}
\end{center}
%\end{figure}


Para empezar a trabajar con Andengine debemos crear un proyecto
Android nuevo dentro de eclipse, crear una carpeta libs en el
directorio del proyecto e incluir andengine.jar (disponible en la
página principal de Andengine)

\begin{center}
  \includegraphics[width = 16 cm]{img/10.jpg}
\end{center}

\clearpage
\subsection{Primer contacto}
Vamos a ver un primer ejemplo para AndEngine.

La clase principal para nuestra aplicación es
\emph{BaseGameActivity}. De esta clase debe heredar nuestra clase principal:

\begin{verbatim}
public class PracIso2 extends BaseGameActivity {
\end{verbatim}

dentro de esta clase tendremos nuestro \emph{Engine}, encargado de
crear el \emph{SurfaceView}, dentro de este \emph{SurfaceView} irá
dibujado el \emph{Engine}. Para cada \emph{BaseGameActivity} tendremos
un \emph{Engine}

Al heredar de \emph{BaseGameActivity} debemos implementar:

\begin{itemize}
\item \emph{onLoadEngine} Encargado de iniciar el engine del juego.
\item \emph{onLoadResources} Reserva memoria para los recursos, imágenes, música,
  fuentes, etc.
\item \emph{onLoadScene} Carga los recursos en la scene.
\item \emph{onLoadComplete} Código a ejecutar una vez terminado los anteriores.
\end{itemize}
{\tiny
\begin{verbatim}
public class PracIso2 extends BaseGameActivity {
 private static final int CAMERA_WIDTH = 800;
 private static final int CAMERA_HEIGHT = 480;

 @Override
 public Engine onLoadEngine() {
  this.mCamera = new Camera(0, 0, CAMERA_WIDTH, CAMERA_HEIGHT);
  Engine engine = new Engine(new EngineOptions(true,
        ScreenOrientation.LANDSCAPE, new RatioResolutionPolicy(CAMERA_WIDTH,
            CAMERA_HEIGHT), camera).setNeedsSound(true));
  return engine
 }

 @Override
 public void onLoadResources() {
 }

 @Override
 public Scene onLoadScene() {
  _scene = new Scene();
  return scene;
 }

 @Override
 public void onLoadComplete() {
 }
}

\end{verbatim}
}

Como vemos en el código, el primer paso es crear una cámara con la
resolución que queramos darle al juego. Esta cámara es el atributo
principal a la hora de crear el engine. También le debemos indicar
otras opciones como orientación de la pantalla.
Este engine creado hará que el juego se desarrolle en pequeños pasos
discretos de tiempo. El Engine se encarga de sincronizar los refrescos
en pantalla y de actualizar la escena. Recordemos que cuando nos
referimos a escena no es solamente el apartado gráfico sino todo el
contenido del juego.

\begin{verbatim}
 public Engine onLoadEngine() {
  this.mCamera = new Camera(0, 0, CAMERA_WIDTH, CAMERA_HEIGHT);
  Engine engine = new Engine(new EngineOptions(true,
                  ScreenOrientation.LANDSCAPE,
                  new RatioResolutionPolicy(CAMERA_WIDTH,
                  CAMERA_HEIGHT), camera).setNeedsSound(true));
  return engine
 }
\end{verbatim}

En \emph{onLoadScene} reservamos recursos para una scene vacía. La
scene será el contenedor de todos los objetos. La escena tiene una
cantidad específica de Layers (capas) y estos Layers tienen una
cantidad (fija o dinámica) de entidades (Entity). Por ejemplo para
añadir un color al fondo sería:

\begin{verbatim}
 public Scene onLoadScene() {
  _scene = new Scene();
  _scene.setBackground(new ColorBackground(0f,1f,0f));
  return _scene;
 }
\end{verbatim}

Para incluir algo más en esta toma de contacto veremos como mostrar
los scripts:

\begin{verbatim}
@Override
  public void onLoadResources() {
    this.mTexture =
      new Texture(32, 32, TextureOptions.BILINEAR);
    this.mTextureRegion =
      TextureRegionFactory.createFromAsset(
        this.mTexture, this, "image.png", 0, 0);
    this.mEngine.getTextureManager().loadTexture(this.mTexture);
  }

  @Override
  public Scene onLoadScene() {
    _scene = new Scene();
    scene.setBackground(new ColorBackground(0f, 1f, 0f));

    _sample_sprite = new Sprite(344, 224, this.mTextureRegion);
    _scene.getLastChild().attachChild(_sample_sprite);

    return _scene;
  }
\end{verbatim}

\clearpage
Lo primero es definir un objeto Texture. Con esto el posicionamiento
de la imagen en la textura, al cargarla en memoria, será manual.
La textura debe tener las mismas dimensiones que la imagen a cargar,
en este caso 32x32.

Las imágenes a utilizar se buscaran por defecto en "assets", de modo
que la ruta es relativa a este directorio. En el ejemplo utilizamos
nuestra ``image.png'' cuando creamos el TextureRegion.

En \emph{onLoadScene} creamos una escena con una sola capa, en el
constructor del objeto Scene establecemos el número de capas que
queremos que tenga.

Lo que hemos echo ha sido crear un Sprite pasándole en su constructor la posición que
queremos que tenga en la escena [400, 240] y el TextureRegion hace
referencia a la imagen cargada que queremos que tenga este Sprite.

Una vez tenemos el Sprite creado, lo añadimos a la escena del juego.

El método de instancia getLastChild de Scene devuelve la capa superior
de la escena. Para obtener la capa que está abajo del todo
utilizaremos el método de instancia getFirstChild de Scene. En este
ejemplo, nuestra escena la hemos creado sólo con una capa, así que
esta será la que está arriba del todo y la que está abajo del todo.

Esto sería un ejemplo simple. Uno de los puntos fuertes de AndEngine
es su documentación basada en ejemplos, podemos descargarnos un
repositorio completo con las últimas versiones desde su página oficial
\href{http://code.google.com/p/andengineexamples}{AndEngineExamples}.


\section{Aplicación realizada}%Desarrollo realizado}
\subsection{Idea inicial.}
La idea inicial de la aplicación es realizar un videojuego atractivo
por su simplicidad y el toque gracioso referente a la carrera de
ingeniería informática.
En un principio se barajaron barios tipos de variantes dentro del
género elegido (plataformas) entre un casual/lineal, como ha sido
elegido) o un jumping. Tras probar varios juegos de este tipo los miembros del equipo
decidieron por unanimidad el tipo lineal por ser más entretenido y
tener mayor jugabilidad.
Con respecto a la temática se pretende asociar al personaje con un
alumno de la escuela superior de informática, debiendo ganarse los
créditos ECTS (puntuación) con la finalidad de terminar la carrera. En
el juego se incluirán elementos asociados a la escuela tales
como entornos o personajes afines a la carrera como profesores, que te
dificultarán el obtener los preciados créditos ECTS. La finalidad es
dar al juego un componente gracioso que aumente su atractivo.

\clearpage
\subsection{Resumen de características.}
\begin{itemize}
  \item {\bf Genero.}
    El juego realizado es un plataformas/casual inspirado en otros
títulos como {\em Line Runner} o {\em BIT.TRIP RUNNER}.
  \item {\bf Jugadores.}
    El juego es para un jugador por dispositivo y sin juego en red.
  \item {\bf Historia.}
    El personaje debe conseguir el máximo de créditos posible para terminar su
    carrera satisfactoriamente y encontrar un trabajo decente en alguna
    factoría de software.
  %\input{bocetos}
  %\input{lookandfeel}
  \item {\bf Interfaz.}
    La interacción con el jugador se realiza a través de la pantalla
    táctil. Una pulsación rápida para saltar y una pulsación más
    prolongada para un salto mayor. La pulsación es detectada en
    cualquier punto de la pantalla.
  \item {\bf Objetivos.}
    El jugador deberá ganar el máximo de créditos posible. No hay un final
    definido, es una metáfora sobre lo interminable que se hace la carrera. Se
    plantea poder subir los créditos a un servidor, para poder competir con
    otros jugadores.
  \item {\bf Reglas.}
    Simplemente hay que esquivar los obstáculos e intentar coger los
    objetos que aportan créditos.
  \item {\bf Gameplay.}
    El juego es de naturaleza casual, con una interacción sencilla con el
    usuario.
  \item {\bf Diseño de niveles.}
    El escenario se genera aleatoriamente a media que el personaje avanza. Se
    plantea también aumentar la complejidad según la puntuación alcanzada.
  \item {\bf Requerimientos técnicos.}
    Cualquier dispositivo con sistema operativo Android.
\end{itemize}

\subsection{Preview de la primera beta}
En esta primera versión los fondos son los proporcionados por los
ejemplos de AndEngine a excepción del suelo.
%\begin{figure}[h!]
\begin{center}
  \includegraphics[width = 10 cm]{img/11.jpg}

  \includegraphics[width = 10 cm]{img/12.jpg}
\end{center}
%\end{figure}


\section{Marketing.}
Principalmente, se hará publicidad a través de las redes sociales (facebook,
tuenti, twitter, ...). Se plantea tambien ofrecer ofertas (mitad de precio,
gratis durante unas horas, ...) y anunciarlo a través de otros hipotéticos
juegos hechos por la empresa.

\section{Diagramas.}
\subsection{Casos de uso.}
\begin{figure}[h]
\centering
\includegraphics[width = 10 cm]{casos_de_uso_(menu).eps}
\caption{Menú.}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width = 10 cm]{casos_de_uso_(juego).eps}
\caption{Juego.}
\end{figure}

\clearpage

\input{presupuesto}

\section{Trabajo pendiente.}

Finalizar el juego añadiendo los elementos que faltan:

\begin{itemize}
  \item Menú.
  \item Cambio del sprite del jugador.
  \item Si da tiempo, añadir sonido.
\end{itemize}

Añadir a este documento los diagramas que faltan.


\section{Fuentes}
\href{http://developer.android.com/index.html}{Android Developer}

\href{http://www.andengine.org/}{AndEngine}

\href{https://github.com/nicolasgramlich/AndEngine}{AndEngine github repository}

\href{http://droideando.blogspot.com.es}{Droideando blogspot}

\end{document}
